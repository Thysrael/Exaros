# Make

## risc-v ISA

现代操作系统一般都是使用 64 位架构进行开发。使用 64 位架构的主要优势在于可以使用更多的内存和更强大的处理器，从而提供更好的性能和吞吐量。具体来说，64 位架构支持更大的虚拟内存地址空间和物理内存容量，可以支持更大的程序和数据集。此外，64 位架构还支持硬件级别的内存保护和更强大的浮点运算能力，在某些应用场景下也非常重要。所以我们选择 64 位的交叉编译器去开发我们的操作系统。

```makefile
# use 64 bit arch cross compiler
CROSS_COMPILE	:= riscv64-unknown-elf-
```

`riscv64-unknown-elf-gcc` 编译器的默认 `-march` 选项是 `rv64imafd`。这个选项指示编译器生成针对 RV64I、M、A、F 和 D 标准的 RISC-V 64 位 ELF 可执行文件。

具体来说，`-march=rv64imafd` 选项分别表示：

- `rv64i` 表示基础标准，64 位寄存器的整型指令集。
- `m` 表示常见的整型乘除扩展指令，包括和、异或和求和指令。
- `a` 表示原子操作指令集，用于并发编程。
- `f` 表示 32 位浮点指令集。
- `d` 表示 64 位浮点指令集。

`rv64imafd` 实际上是 `rv64g` 指令集的一个子集，具体区别如下：

- `rv64g` 是 RISC-V 64 位指令集的一个扩展，它包括 `rv64i`（基本整数指令集）、`rv64m`（整数乘法/除法扩展）、`rv64a`（原子指令扩展）以及 `rv64f` 和 `rv64d`（浮点指令扩展）。而 `rv64imafd` 是基于这些扩展的一部分组成的子集，缺少了 `g` 扩展，即缺少了压缩指令集扩展（C）。
- `rv64g` 中增加了两个压缩指令集扩展，分别是 `C` 和 `Z` 扩展，其中 `C` 扩展是基于乘法的指令集扩展，可以生成加、减、比较和分支指令，而 `Z` 扩展是用于压缩的指令集扩展，可以将指令压缩到 16 位。这些指令集扩展可以提高处理器性能和代码密度，同时还能减少能耗和成本。
- `rv64imafd` 指令集的主要特点是支持整数运算、软件中断、浮点数运算等基本指令集，但不包括压缩指令扩展。因此，在空间上占用更大一些，但也可运行更多的软件。

总之，`rv64imafd` 和 `rv64g` 在 RISC-V 64 位指令集的基础上，使用不同的指令扩展进行了不同的优化和扩展。对于具体的应用场景，可以根据需要选择不同的指令集，以达到更好的性能和代码密度。

---



## GCC Flags

| 参数                     | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| -Wall                    | 发现所有的警告信息                                           |
| -Werror                  | 将警告信息作为错误处理，即若有警告信息产生，则直接停止编译   |
| -O                       | 优化编译，可以提高程序的运行效率                             |
| -fno-omit-frame-pointer  | 确保生成的代码可以准确地将控制流信息通知给调试器             |
| -ggdb -g                 | 产生供GDB使用的调试信息，方便程序的调试和追踪                |
| -march=rv64g -mabi=lp64f | 设置目标平台的指令集架构和数据模型，即64位RISC-V指令集架构和小端序的LP64数据模型 |
| -MD                      | 生成依赖关系文件                                             |
| -mcmodel=medany          | 指定生成目标代码的内存模型，适用于任何内存大小，但需要通过中等通用的加载程序段（GP）来寻址 |
| -mcmodel=medany          | 指定了生成的目标代码的内存模型                               |
| -ffreestanding           | 剔除依赖于操作系统的部分，使生成的二进制程序可以独立运行     |
| -fno-common              | 不允许重复定义共享变量                                       |
| -nostdlib                | 不使用标准库                                                 |
| -mno-relax               | 禁用relaxation，生成的汇编代码不应该包含relaxation指令       |
| -I.                      | 加入当前目录到头文件的搜索路径中                             |
| -fno-stack-protector     | 禁用堆栈保护功能，降低程序负担                               |



## LD Flags

| 参数                  | 含义                       |
| --------------------- | -------------------------- |
| -z max-page-size=4096 | 允许的最大页大小为4096字节 |



## Qemu Flags

| 参数名     | 参数值  | 解释                                                         |
| ---------- | ------- | ------------------------------------------------------------ |
| machine    | virt    | 这个标志指定了QEMU虚拟机的机器类型为虚拟化主机               |
| -bios      | default | 这个标志表示使用默认的BIOS镜像，BIOS负责检查硬件设备并引导操作系统 |
| -m         | 128M    | 这个标志表示设置虚拟机的内存大小为128MB                      |
| -nographic |         | 这个标志表示在启动时切换到非图形化控制台模式，可以在命令行环境下运行虚拟机 |
| -d         | in_asm  | 在模拟器中跟踪和记录指令级别的执行过程并输出汇编指令         |
| -d         | int     | 输出模拟器模拟执行时发生的中断、异常等事件的详细信息         |
| -s         |         | QEMU 将启动一个 GDB 服务器并监听本地主机的 1234 端口（默认值），可以让 gdb 连接 QEMU 内的调试服务器，通过 gdb 命令来控制 QEMU 的执行、查询内存和寄存器等信息，方便调试应用程序 |
| -S         |         | 在启动时暂停虚拟机，等待 gdb 连接，等待 gdb 客户端的连接后才会开始执行。此选项用于在 QEMU 启动时挂起，以进行远程调试 |





## debug

debug 的原理是利用 qemu 启动的服务器监听主机的 `1234` 端口，gdb 连接这个服务器，用 gdb 命令来控制 qemu 的执行，对其上的操作系统进行调试。

所以在进行这个过程的时候，需要开启两个终端，一个终端运行 `make debug` ，即如下命令

```makefile
$(QEMU) -kernel $(exaros_bin) $(QFLAGS) -s -S
```

而另一个终端与其进行通信，运行 `make gdb`，即如下命令（此时加载 `elf` 应该是为了获得符号表等信息）

```shell
$(GDB) $(exaros_elf)
```

在 `gdb` 这个进程中，需要先输入以下命令进行连接

```shell
(gdb) target extended-remote localhost:1234
```

为了自动化，避免多次输入，可以在项目根目录下新建 `.gdbinit` 文件，避免每次的输入

```shell
target extended-remote localhost:1234
```

有一定概率这个 `init` 文件不会被加载，因为不太安全，此时可以在 `~/.config/gdb/gdbinit` 中加入如下指令即可

```shell
add-auto-load-safe-path <progject->/.gdbinit
```

`gdb` 的命令如下

| 命令               | 缩写   | 含义                                 |
| ------------------ | ------ | ------------------------------------ |
| `file`             |        | 加载一个可执行文件                   |
| `run`              | `r`    | 运行程序                             |
| `breakpoint`       | `b`    | 在指定位置设置断点                   |
| `delete`           | `d`    | 删除一个或多个断点                   |
| `continue`         | `c`    | 继续执行程序                         |
| `step`             | `s`    | 单步执行程序，并进入任何被调用的函数 |
| `next`             | `n`    | 单步执行程序，但不进入被调用的函数   |
| `finish`           | `fin`  | 执行程序，直到当前函数返回           |
| `up`               | `u`    | 进入当前调用堆栈的上层函数           |
| `down`             | `d`    | 进入当前调用堆栈的下层函数           |
| `print`            | `p`    | 显示一个变量的值                     |
| `set`              |        | 设置一个变量的值                     |
| `display`          | `disp` | 启动一个计算某个值的监视             |
| `undisplay`        |        | 取消一个监视                         |
| `list`             | `l`    | 显示源代码                           |
| `backtrace`        | `bt`   | 显示调用链和函数参数                 |
| `info breakpoints` | `i b`  | 显示断点列表                         |
| `info functions`   | `i f`  | 显示程序中的函数列表                 |
| `info locals`      | `i lo` | 显示当前函数中的局部变量             |
| `info variables`   | `i va` | 显示当前程序中所有可访问的全局变量   |
| `quit`             | `q`    | 退出gdb                              |
