# Grammer

## inline assembly

最标准化的形式应该如下所示

```c
asm volatile(
	汇编指令模板列表
	∶输出操作数 //非必需
	∶输入操作数 //非必需
	∶可能影响的寄存器或存储器 //非必需
);
```

其中 `asm` 表示内联汇编，`volatile` 表示禁止编译器优化，放置造成错误。

汇编指令模板列表指的是一系列类似于汇编指令的列表。之所以称其为类似，是因为它存在一些匹配符（模板寄存器），可以用于关联 C 中的变量，比如说下面的例子

```c
"add %[dest], %[src1], %[src2]"
```

这里的 `dest, src1, src2` 都不是汇编中的寄存器，但是允许这种形式的存在。

所谓的“列表”指的是可以有多条汇编指令，每条汇编指令之间要用 `\n\t` 进行分割。

输出操作数和输入操作数用于关联 C 中的变量和模板寄存器，如下所示

```c
:[dest]"=r"(sum)                	// 将 add 指令的目标操作数 dest 和 C 程序中的 sum 变量绑定。
:[src1]"r"(add1),[src2]"r"(add2)	// 将 add 指令的源操作数 src1 和 C 程序中的 add1 变量绑定，src2 类似
```

引号中的限制字符串（上例中的 `"=r", "r"`），用于约束此操作数变量的属性，常用的约束如下：

- 字母 `"r"` 表示使用编译器自动分配的寄存器来存储该操作数变量；字母 `"m"` 表示使用内存地址来存储该操作数变量。如果同时指明 `"rm"`，则编译器自动选择最优方案。
- 对于"输出操作数"而言，`"="` 代表输出变量用作输出，原来的值会被新值替换；`"+"` 代表输出变量不仅作为输出，而且作为输入。

除了 `%[str]` 中明确的符号命名指定外，还可以使用 `%数字` 的方式进行隐含指定。"数字"从 0 开始，依次表示输出操作数和输入操作数。假设包含"输出操作数"列表中有 2 个操作数，"输入操作数"列表中有 2 个操作数，则汇编程序中 `%0` 表示第一个输出操作数，`%1` 表示第二个输出操作数，`%2` 表示第一个输入操作数，`%3` 表示第二个输入操作数。

可能影响的寄存器或存储器，用于告知编译器当前内联汇编语句可能会对某些寄存器或内存进行修改，使得编译器在优化时将其因素考虑进去，常见的有 `a0, memory` 等。

此外如果想要一直读写寄存器的值，那么除了用汇编语句外，还可以用如下形式：

```c
register u64 C_a0 asm ("a0");
```

此时的 `C_a0` 就建立和寄存器 `a0` 的映射，对于 `C_a0` 的读写，就是对于 `a0` 的读写。在下面的例子中体现地较为明显：

```c
inline int getcharSBI() {
    register u64 a7 asm ("a7") = (u64) SBI_CONSOLE_GETCHAR; // write a
    register u64 a0 asm ("a0");
    asm volatile ("ecall" : "+r" (a0) : "r" (a7) : "memory");
    return a0; // read a0
}
```

