# bug

这个文档记录一下十分困难的 bug。

## 板子幽灵抽奖

libcbench 在上板子的时候随机位置 panic，但是在 qemu 上无法复现。

本质是因为 qemu 并不模拟 icache 结构，当 fork 时同步（fence 指令）不完全，则会出现这个现象。

## man 手册中的语焉不详

我们在实现 brk 的时候按照 man 去设置我们的返回值，后来发现无法启动 lmbench 的初始化。

这是因为实际上的 linux brk 的行为并不与 man 手册一致，我们按照 man 手册的实现无法满足 lmbench 的要求。具体的差异现象在这篇[博文](https://blog.csdn.net/pk_20140716/article/details/49736935)中有详细描述。修改后即可运行。

## 傻憨憨的写回策略

我们一开始为了保证一致性，对于写外存缓冲块采用写穿策略，这样每次写外存，都会读写 SD 卡。然后 iozone 就会巨慢无比。

后来调整了写回策略和 buffer 的大小，速度百倍上升。

## 未知的动态链接访存异常

在实现动态链接时，qemu 在执行动态链接解释器的代码时，总是出现非常奇怪的访存行为，导致访存错误，scause 的值是 0xd，但是如果上板测试，则不会出现这种情况。

后来通过查阅 RISCV ISA 得知，有一些 PTE 权限位虽然要求由硬件维护，但是并不是强制要求，所以猜测可能是 qemu 模拟时并没有模拟部分权限位，所以我将这部分权限位改成了软件维护，于是不再异常。

## 指针类型转换

在实现 macb 驱动时，有一个部分是照着一份 rust 驱动翻译的（因为实在是看不懂），但是翻译后却发现无法运行，情绪接近崩溃。

最后发现是指针类型转换造成的符号拓展问题。肉眼 de 出 bug。

## Select 的重入问题

系统调用 select，总会造成卡死的情况。

在讨论时提到“信号的重入问题”时，突然联想到 select 因为阻塞特性，也有一个反复重新执行的过程，而重复执行时，应当保证内存不发生变化（重入要求资源的不变性）。检查代码发现 copyout 的执行过于早，导致修改了用户内存。

## 心力憔悴的 socket

反正就是 de 了一堆 bug，最后死在了 setsocketopt，没有充足的单元测试，无法进行开发。